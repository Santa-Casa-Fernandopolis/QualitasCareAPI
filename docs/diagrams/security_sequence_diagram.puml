@startuml
hide footbox
title Fluxo de decisão de acesso (Sequence)

actor Controller
participant "PermissionEvaluator" as PE
participant "CurrentUserExtractor" as CUE
participant "TargetLoader" as TL
participant "AccessDecisionService" as ADS
participant "PolicyEvaluator" as PEV
database "Repos (Overrides/Policies/RolePerms)" as REPO

Controller -> PE: hasPermission(auth, targetId, targetType, "NC:READ@DETALHE")
PE -> CUE: from(auth) -> AuthContext
CUE -> CUE: ler claims JWT (user_id, tenant_id, department, status, origin, atributos opcionais)
CUE -> CUE: inferir tenant via roles TENANT_* quando ausente
CUE -> CUE: defaults seguros (status=ACTIVE, origin=LOCAL)
PE -> PE: parse("NC:READ@DETALHE") -> (res=NC, act=READ, feature=DETALHE)
PE -> TL: load(targetType, targetId) -> alvo
PE -> ADS: isAllowed(ctx, res, act, feature, alvo)

ADS -> ADS: negar se ctx.isActiveUser() == false
ADS -> ADS: negar se tenantId ausente
ADS -> ADS: permitir se ctx.hasRole("SYSTEM_ADMIN")
ADS -> REPO: find UserPermissionOverride (exato + feature=NULL)
REPO --> ADS: override? (ALLOW/DENY) [opcional]
ADS -> ADS: if override DENY -> negar; if ALLOW -> permitir

ADS -> REPO: find Policies (res, act, feature or NULL) ordered by priority
REPO --> ADS: policies[]
loop por prioridade
  ADS -> PEV: matchesAll(policy, ctx, alvo)?
  PEV --> ADS: true/false
  ADS -> ADS: validar filtros de role e tokens dinâmicos
  ADS -> ADS: if DENY aplicável -> negar imediatamente
  ADS -> ADS: if ALLOW aplicável -> permitir (se nenhum DENY mais prioritário)
end

ADS -> ADS: se alguma policy avaliada e nenhuma casar -> negar (no_policy_matched)

ADS -> REPO: exists RolePermission (res, act, feature or NULL, roles, tenant)
REPO --> ADS: true/false
ADS -> PE: resultado final (true/false)

PE --> Controller: permitir (200) ou negar (403)
@enduml
